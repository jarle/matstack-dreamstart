---
description: 
globs: resources/remix_app/**/*
alwaysApply: false
---
- The remix app root is aliased as `#web/` for imports
- Remix is now merged into React Router. Import remix code from `react-router`.
- `json`/`defer` are now deprecated, there's no need to wrap return objects/promises in these.
- Typing of actions and loaders are described in [remix-types.mdc](mdc:.cursor/rules/remix-types.mdc): tldr: loader/action types are typegenerated by react-router.
- Environment variables can be accessed from the context ([remix-service-interaction.mdc](mdc:.cursor/rules/remix-service-interaction.mdc)): `const env = await make('env')`
- Always throw redirects to ensure proper type inference in loaders and actions:
```ts
// Correct - throws the redirect
throw redirect('/path')
```
- Use inline mapping when returning DTOs from loaders/actions.
- The DTO should only contain the minimal number of fields that are needed by the UI components.
- Let TypeScript infer the types without explicit type annotations
- In auth routes, the current user is available on the http context auth property:
`const user = http.auth.getUserOrFail().user`
  - Do not add error handling for this; assume the user is authenticated
- The Remix code should only interact through the IoC container, and not have direct code dependencies on the AdonisJS code.
- Most work should be done in the service layer, avoid doing too much in actions and loaders.
- On the `context` object you find the AdonisJS http context and the AdonisJS IoC container. This is the primary way the Remix app communicates with the backend.
- Services are added to the Adonis IoC container with string literals in @_index.ts, there you can see all available services. 
- Use Locality of Behavior - for example keep route-specific components inside a given route folder instead of common components folder.
- Prefer small, focused components and functions
- Prefer composition over conditional rendering of react components
- Use inline types for react component props, for example `(props: { id: string })`
  - If a component is closely linked to loader data, infer the component type from the loader return type with the globally declared type helpers `LoaderField` or `SuspendedLoaderField`.
    - For example local component declaration: `type Settings = LoaderField<typeof loader, 'settings'>`
    - Keep component structure in mind when creating loader DTO shapes
- Loaders/actions should not throw exceptions. Wrap calls in `withErrorHandling` like this:
```ts
  const r = await withErrorHandling(
    async () => await http.request.validateUsing(actionValidator)
  )
```
- Tech stack:
  - Node.js
  - React Router (Previously called Remix)
  - AdonisJS
  - VineJS for validation
  - React
  - Tailwind
  - DaisyUI
  - Lucid icons